#ifndef _MY_SCENE_H_
#define _MY_SCENE_H_

#include "cse452.h"
#include "Color.h"
#include "camera/Camera.h"
#include "parser.h"
#include "Light.h"
#include <FL/Fl_Image.H>
#include <string>
#include <vector>

#include <map>
#include "../Shapes/MyShape.h"

using namespace std; //removing annoying std::

/*
 * This class holds all of the data in the scene file.
 *  Camera
 *  Lights
 *  Subgraphs
 *  Root subgraph
 */

// ToDo: Define these
class Object;
class Node;
class Tree;
class Trans;
class MatObj; //additional class, below

class MyScene {
public:
    MyScene();
    ~MyScene();

    // The start of the parsing routine
    // Called once when a new scene file is opened
    bool loadSceneFile(std::string filename);

    // Return the current error mesage (if any) generated by parsing
    std::string getErrorMessage() const;

    // Return the parsed camera
    Camera &changeCamera();

    // Return the parsed camera
    const Camera &getCamera() const;

    // Return the parsed camera
    const Color &getBackground() const;

    // Called when the window is re-sized
    void resize(int w, int h);
    // Called when the window needs to be re-drawn
    // Stub can be found in sceneview/MyScene_draw.cpp
    void draw();
    
    /* 
     * The following are for the user interaction assignment 
     * Stubs for them can be found in Interactive/MySceneSelect.cpp
     */
    // User clicked on the screen; find the corresponding shape
    bool selectNode(int x, int y);
    //
    void moveSelectedNode( const Matrix4 &matChange );
    
    /*
     * The following are for the ray tracing assignment
     * Stubs for them can be found in rendering/MyScene_render.cpp
     */
    // 
    void render(int type, int width, int height, unsigned char* pixels);
    void stopRender();
    double getRenderProgress();
    
    /* ========== added methods and variables =========== */
  	//methods
  	// put a pixel on the canvas, (r, g, b) are to be given in the [0,1] range
  	void putPixel(int x, int y, const Color &in_col, unsigned char* pixels);
	void renderPixels(int width, int height, unsigned char* pixels);
	Vector3 generateDir(int width, int height, double x, double y);
	
	void renderRayTracing(int width, int height, unsigned char* pixels);
	
	Color ambientIllumination(MatObj *matObj);
	Color diffuseIllumination(MatObj *matObj, Point3 pHit, Vector3 nHit, Light* light);
	Color specularIllumination(MatObj *matObj, Vector3 ray, Point3 pHit, Vector3 nHit, Light *light);
	
	void rayObjectIntersect(Point3 p, Vector3 d, Point3& hitP, Vector3& hitN, MatObj*& hitObj);
	Color illuminationModel(Vector3 d, Point3 p, int limit);
  	
  	//variables
	static const int RECURSIVE_LIMIT = 3;
	double rProgress;
	int rWidth;//the width of the rendering window
	int rHeight;//the height of the rendering window
	bool isRendering;//true if rendering, false if we need to stop


    /*
     * The following are for the sceneview assignment
     * They can be found in sceneview/MyScene.cpp
     */
    // Clear out any existing data
    void resetScene();

    // Gets the background color from the scenefile
    bool parseBackground(Parser& p);

    // Gets the camera info (if any) from the scene file
    bool parseCamera(Parser& p);

    // Gets the light info (if any) from the scene file
    bool parseLight(Parser& p);

    /*
     * The following are the parsing routines you need to finish filling in.
     * Feel free to change the return type or pass in additional parameters.
     */
    // Called when subgraph _name_ [ is encountered in the scene file
    // Should return true when root subgraph encountered
    Tree* parseMasterSubgraph(Parser& p);

    // Called when trans [ is encountered
    Node* parseTrans(Parser& p);

    // Called when Object _name_ [ is encountered
    Object* parseObject(Parser& p);
  	
private:
    // Has loadSceneFile been called yet?
    bool isLoaded;
    // Keep track of the current error message
    std::string errorMessage;
    
    // Store camera info; remember that your default camera should be
    // set to reasonable values in case there is no camera information
    // in the scene file
    Camera camera;

    // Stores the background color found in the scenefile (if any).
    // Defaults to black
    Color background;

    // The stored lights
    Color ambientLight;
    std::vector<Light> lights;

    // your functions/variables go here
    
    //shapes
    MyShape* cube;
	MyShape* sphere;
	MyShape* cone;
	MyShape* cylinder;
	MyShape* torus;
	
	//a named subgraph: the name of the subgraph is the key and the Tree type is the mapped value 
	map<string, Tree*> masterSubgraphs;
	
	//a list of objects in the subgraph
	list<MatObj> objectL;
	
	//normalization function for colors
	Color normCol(Color col);
	
	bool seenTransform;//have we seen a transformation in this subgraph?
	bool seenObject; //have we seen an object/subgraph already in this mastersubgraph? 
	//if true and we see another object/subgraph just ignore the second object
	//if false and seenTransform is true and we see TOKEN_CB throw an error message
	
    void clearMasterSubgraph();//deletes the Tree and clears the subgraph
	
};

/////////////////////
// These are for the classes
class MatObj{ // this stores the object alongside its transformation matrices
public:
	//constructor
	MatObj(Matrix4 mat_, Object* obj_); 
	~MatObj();
	Matrix4 mat;
	Object* obj;
};

class Node {
public:
	Node();
	~Node();
	virtual void createChildList(Matrix4& m, list<MatObj>* l);
	
protected:
	bool isObj;
};

class Object : public Node {
// This is the base level of the tree (tree leaf)
// it stores shape and surface quality
public:
	//constructors: set the object and the color characteristics + texture
	Object(); //in this case there is no shape predefined
	Object(MyShape* s); //this handles the case of a primitive shape (cube, sphere, cylinder, cone)
	~Object();
	
	void drawObj();
	
	void createChildList(Matrix4& m, list<MatObj>* l);
	
	void setAmbient(Color col){ambient=col;};
	Color getAmbient(){return ambient;};
	void setDiffuse(Color col){diffuse=col;};
	Color getDiffuse(){return diffuse;};
	void setSpecular(Color col){specular=col;};
	Color getSpecular(){return specular;};
	void setReflect(Color col){reflect=col;};
	Color getReflect(){return reflect;};
	void setTransparent(Color col){transparent=col;};
	Color getTransparent(){return transparent;};
	void setEmit(Color col){emit=col;};
	Color getEmit(){return emit;};
	
	void setShine(double s){shine=s;};
	double getShine(){return shine;};
	void setAlpha(double s){alpha=s;};
	double getAlpha(){return alpha;};
	
	void setIor(double s){ior=s;};
	double getIor(){return ior;};
	void setU(double s){textureU=s;};
	double getU(){return textureU;};
	void setV(double s){textureV=s;};
	double getV(){return textureV;};
	string getTexture(){return texture;}
	void setTexture(string s){texture=s;}
	
	MyShape* getShape(){return shape;};	
	void setShape(MyShape* s){shape=s;};
	
	Color black, white;
	
	//since I am using an alpha value of .8 and GL_DIFFUSE as the light, I need to know if the object is transparent or not
	bool isTransparent;
	
private:
	Color diffuse, specular, ambient, reflect, transparent, emit;
	double shine, ior, textureU, textureV, alpha;
	string texture;
	MyShape *shape;
};

class Tree : public Node{
//Your scene is composed of trees. A tree is simply a list of nodes.
public:
	Tree();
	~Tree();
	void addTrans(Trans* t); //add a transformation to transL
	void clearTransL();//clear the transformation list
	void createChildList(Matrix4& m, list<MatObj>* l); //creates the list of trasforms
	
private:
	list<Trans*> transL;
};

class Trans: public Node{ 
//A translation (transformation) block
public:
	Trans();
	~Trans();
	
	void addMat(Matrix4 m); //row-major order
	void AddNode(Node *n); //which object do we apply this to
	void createChildList(Matrix4& m, list<MatObj>* l); //creates the list of trasforms

private:
	Matrix4 mat;//accumulated matrix
	Node* node;
};

#endif /* _MY_SCENE_H_ */
